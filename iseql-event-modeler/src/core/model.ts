/**
 * ISEQL Event Modeler — Core AST
 *
 * Task M3 — Core: AST (model.ts)
 * Gate: unit test creates a minimal model and asserts a stable JSON snapshot.
 *
 * Minimal assumptions (declared):
 * - IDs are string-based and generated by a deterministic local factory.
 * - Infinity for thresholds is represented as the string "∞".
 */

type Brand<T, B extends string> = T & { readonly __brand: B };

export type ModelId = Brand<string, "ModelId">;
export type IntervalId = Brand<string, "IntervalId">;
export type RelationId = Brand<string, "RelationId">;
export type ConstraintId = Brand<string, "ConstraintId">;

export type Tick = number;

/**
 * ISEQL comparator symbols (SPEC uses ≤ by default).
 * We keep them as unicode to match eventual serializer output.
 */
export type Comparator = "<" | "≤" | "=" | "≥" | ">";

/**
 * Threshold values (δ, ε) can be finite numbers or Infinity.
 * Assumption: we represent Infinity as the string "∞".
 */
export type Threshold = number | "∞";

/**
 * Core temporal parameters (SPEC MVP).
 * Defaults: ζ=≤, η=≤, δ=∞, ε=∞, ρ=0
 */
export interface TemporalParams {
  zeta?: Comparator; // ζ
  eta?: Comparator; // η
  delta?: Threshold; // δ
  epsilon?: Threshold; // ε
  rho?: number; // ρ
}

export const DEFAULT_TEMPORAL_PARAMS: Required<TemporalParams> = {
  zeta: "≤",
  eta: "≤",
  delta: "∞",
  epsilon: "∞",
  rho: 0,
};

/**
 * Allen relation aliases (UI-only); internal model remains ISEQL-native.
 * (Complete set as per SPEC; used only as an optional label/alias.)
 */
export type AllenRelation =
  | "Before"
  | "After"
  | "Meets"
  | "MetBy"
  | "Overlaps"
  | "OverlappedBy"
  | "Starts"
  | "StartedBy"
  | "During"
  | "Contains"
  | "Finishes"
  | "FinishedBy"
  | "Equals";

/**
 * PredicateCall represents a labeled interval instance, e.g. hasPkg(p1,pkg1).
 * Args are kept ordered for deterministic serialization.
 */
export interface PredicateCall {
  name: string;
  args: string[]; // ordered positional args (MVP)
}

/**
 * Interval instance drawn on the timeline.
 */
export interface IntervalInstance {
  id: IntervalId;
  start: Tick;
  end: Tick;
  predicate: PredicateCall;
  /**
   * Optional UI label (e.g., "A", "B") - not required for semantics.
   * Included in model because it is useful for deterministic references in UI.
   */
  label?: string;
}

/**
 * TemporalExpression: a relationship between two intervals.
 * ISEQL-native: operatorId refers to catalog/operator key (to be implemented later).
 * Allen alias may be stored but is not the semantic source of truth.
 */
export interface TemporalExpression {
  id: RelationId;

  left: IntervalId;
  right: IntervalId;

  /**
   * ISEQL operator identifier (e.g., "Bef", "DJ", "SP"...).
   * The operator catalog will live in src/core/operators.json (later task),
   * but the AST stores the chosen operator id.
   */
  operatorId: string;

  /**
   * Optional parameters; omitted fields imply defaults (resolver/serializer later).
   */
  params?: TemporalParams;

  /**
   * Optional Allen alias used in UI; must normalize to ISEQL operator during compilation.
   */
  allenAlias?: AllenRelation;
}

/**
 * Constraints are additional conditions that may apply globally or to a relation.
 * MVP just needs a deterministic structure; richer semantics will come with validator/resolver tasks.
 */
export type Constraint =
  | {
      id: ConstraintId;
      kind: "relationParam";
      relationId: RelationId;
      /**
       * Path-like key to indicate what is constrained.
       * Example: "params.delta" or "params.zeta"
       */
      key: string;
      /**
       * Value stored as JSON-friendly primitive.
       */
      value: string | number | boolean;
    }
  | {
      id: ConstraintId;
      kind: "note";
      message: string;
    };

export interface ConstraintSet {
  constraints: Constraint[];
}

/**
 * Top-level model.
 * schemaVersion is required for save/load (US3) and future migrations.
 */
export interface EventModel {
  schemaVersion: "1.0";
  id: ModelId;

  meta: {
    name: string;
    description?: string;
    createdAtISO: string; // ISO string for determinism in persisted files (test uses fixed value)
  };

  intervals: IntervalInstance[];
  relations: TemporalExpression[];
  constraints: ConstraintSet;
}

// -----------------------------
// Deterministic ID factory
// -----------------------------

export interface IdFactory {
  nextModelId(): ModelId;
  nextIntervalId(): IntervalId;
  nextRelationId(): RelationId;
  nextConstraintId(): ConstraintId;
}

/**
 * Deterministic generator: same prefix + same call order -> same IDs.
 * seed starts at 1 by default.
 */
export function createIdFactory(seed = 1): IdFactory {
  let n = seed;

  const next = (prefix: string) => `${prefix}_${String(n++).padStart(4, "0")}`;

  return {
    nextModelId: () => next("m") as ModelId,
    nextIntervalId: () => next("i") as IntervalId,
    nextRelationId: () => next("r") as RelationId,
    nextConstraintId: () => next("c") as ConstraintId,
  };
}

// -----------------------------
// Model factories (MVP for Gate)
// -----------------------------

/**
 * Creates an empty model with deterministic defaults.
 * createdAtISO is passed in to avoid non-determinism in tests/snapshots.
 */
export function createEmptyEventModel(input: {
  ids: IdFactory;
  name: string;
  createdAtISO: string;
  description?: string;
}): EventModel {
  return {
    schemaVersion: "1.0",
    id: input.ids.nextModelId(),
    meta: {
      name: input.name,
      description: input.description,
      createdAtISO: input.createdAtISO,
    },
    intervals: [],
    relations: [],
    constraints: { constraints: [] },
  };
}

/**
 * Minimal model for the Gate test.
 * One interval with a predicate; no relations/constraints.
 */
export function createMinimalEventModel(): EventModel {
  const ids = createIdFactory(1);
  const model = createEmptyEventModel({
    ids,
    name: "MinimalModel",
    createdAtISO: "2026-02-06T00:00:00.000Z",
  });

  model.intervals.push({
    id: ids.nextIntervalId(),
    start: 0,
    end: 1,
    predicate: { name: "hasPkg", args: ["p1", "pkg1"] },
    label: "A",
  });

  return model;
}

// -----------------------------
// Deterministic snapshot helpers
// -----------------------------

/**
 * Normalize optional params by dropping default-valued keys.
 * This makes snapshots stable even if caller populates defaults explicitly.
 */
export function stripDefaultTemporalParams(
  params: TemporalParams | undefined,
): TemporalParams | undefined {
  if (!params) return undefined;

  const out: TemporalParams = { ...params };

  if (out.zeta === DEFAULT_TEMPORAL_PARAMS.zeta) delete out.zeta;
  if (out.eta === DEFAULT_TEMPORAL_PARAMS.eta) delete out.eta;
  if (out.delta === DEFAULT_TEMPORAL_PARAMS.delta) delete out.delta;
  if (out.epsilon === DEFAULT_TEMPORAL_PARAMS.epsilon) delete out.epsilon;
  if (out.rho === DEFAULT_TEMPORAL_PARAMS.rho) delete out.rho;

  return Object.keys(out).length ? out : undefined;
}

/**
 * Returns a deep-normalized, JSON-safe object:
 * - arrays sorted by id
 * - relation params stripped of defaults
 * - constraints sorted by id
 */
export function normalizeEventModelForSnapshot(model: EventModel): EventModel {
  const intervals = [...model.intervals].sort((a, b) => a.id.localeCompare(b.id));

  const relations = [...model.relations]
    .map((rel) => ({
      ...rel,
      params: stripDefaultTemporalParams(rel.params),
    }))
    .sort((a, b) => a.id.localeCompare(b.id));

  const constraints = {
    constraints: [...model.constraints.constraints].sort((a, b) => a.id.localeCompare(b.id)),
  };

  return {
    ...model,
    meta: { ...model.meta },
    intervals,
    relations,
    constraints,
  };
}

/**
 * Stable stringify: sorts object keys recursively to guarantee byte-for-byte stability.
 */
export function stableStringify(value: unknown, space = 2): string {
  const isRecord = (v: unknown): v is Record<string, unknown> =>
    typeof v === "object" && v !== null && !Array.isArray(v);

  const normalize = (v: unknown): unknown => {
    if (v === null || v === undefined) return v;
    if (Array.isArray(v)) return v.map(normalize);
    if (!isRecord(v)) return v;

    const keys = Object.keys(v).sort();
    const out: Record<string, unknown> = {};
    for (const k of keys) out[k] = normalize(v[k]);
    return out;
  };

  return JSON.stringify(normalize(value), null, space);
}

/**
 * Convenience for tests: normalized model -> stable JSON string.
 */
export function toStableModelSnapshot(model: EventModel): string {
  return stableStringify(normalizeEventModelForSnapshot(model));
}
